\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[polish]{babel}
\usepackage{polski}
\usepackage{hhline}
\usepackage{multirow}
\usepackage{enumitem}
% to make simple tables i use: https://www.tablesgenerator.com/


\title{OpenMP Raport}
\author{Zuzanna Rękawek}
\date{Kwiecień 2021}

\begin{document}
\maketitle

\newpage

\section{Specyfikacja}
\begin{itemize}
    \item Procesor: Intel Core i5-9300H 
    \item Procesory fizyczne: 4
    \item Procesory logiczne: 8
    \item OS: Windows 10
    \item Typ systemu: x64
\end{itemize}
Zadanie zostało wykonane przy użyciu środowiska Microsoft Visual Studio 2019. \\
Wszystkie programy zostały skompilowane z konfiguracją Release, a następnie uruchomione bez debbugowania. 

\section{Przetwarzanie sekwencyjne}
Czas wykonywania obliczeń: 0.196[s]

\section{Pomiary czasu}
Poniższe wartości prezentują długość przetwarzania dla kolejnych wersji kodu w sekundach- podstawowej jednostce czasu układu SI.
\begin{table}[!htb]
\centering
\begin{tabular}{|c|l|l|l|c|}
\hline
\multirow{2}{*}{Przykład} & \multicolumn{3}{c|}{Wątki}                                               & \multirow{2}{*}{Wynik} \\ \cline{2-4}
                      & \multicolumn{1}{c|}{8} & \multicolumn{1}{c|}{4} & \multicolumn{1}{c|}{2} &                        \\ \hline
PI2                   & 0.152412               & 0.168973               & 0.188614               & niepoprawny            \\ \hline
PI3                   & 10.911656              & 7.476831               & 4.132476               & poprawny               \\ \hline
PI4                   & 0.080543               & 0.109149               & 0.115842               & poprawny               \\ \hline
PI5                   & 0.047536               & 0.061145               & 0.114769               & poprawny               \\ \hline
PI6                   & 0.061080               & 0.084447               & 0.105977               & poprawny               \\ \hline
\end{tabular}
\caption{czasy przetwarzania}
\end{table}

\begin{table}[!htb]
\centering
\begin{tabular}{|c|l|l|l|}
\hline
\multirow{2}{*}{Przykład} & \multicolumn{3}{c|}{Wątki}                                               \\ \cline{2-4} 
                          & \multicolumn{1}{c|}{8} & \multicolumn{1}{c|}{4} & \multicolumn{1}{c|}{2} \\ \hline
PI2                       & 1.29                   & 1.16                   & 1.04                   \\ \hline
PI3                       & 0.02                   & 0.03                   & 0.05                   \\ \hline
PI4                       & 2.43                   & 1.80                   & 1.69                   \\ \hline
PI5                       & 4.12                   & 3.21                   & 1.71                   \\ \hline
PI6                       & 3.21                   & 2.32                   & 1.85                   \\ \hline
\end{tabular}
\caption{przyspieszenia}
\end{table}

\newpage

\section{Omówienie działania programów}
\subsection{PI2}
Wprowadzając derektywę $\#pragma\:omp\:paralel\:for$ sprawiono, że zmienna $i$ jest prywatną. Pozostałe zmienne są współdzielone.\\
Znaczącym problemem jest współdzielenie zmiennych $x$ oraz $sum$- są dostępne do odczytu i zapisu. Prywatność zmiennej $x$ możemy uzyskać dzięki każdorazowej deklaracji zmiennej w pętli. Współdzielenie jej jest niepoprawne- każdy wątek oblicza własną wartość. \\
Wieloktrotny zapis i odczyt zmiennej $sum$ powoduje wyścig- możliwość niesynchronizowanych dostępów. Zapis powoduje unieważnienie kopii linii zawierającej tą zmienną w innym procesorze, czego następstwem jest nieporpawny wynik końcowy.\\
Przewidzane przyspieszenie nie występuje w każdym przypadku, ze względu na powyższe problemy z poprawnoscią dostępu do zmiennych. 
\subsection{PI3}
W tym przykadzie lokalność zmiennych nie ulega zmianie. Upewniono się, że zmienna $x$ jest prywatna dla każdego wątku.\\
Efektem użycia dyrektywy $\#pragma\:omp\:atomic$ jest otrzymanie dobrego wyniku. Czas wykonywania obliczeń uległ pogorszeniu. Jest to spowodowane charakterystyką dyrektywy.\\
Dyrektywa $\#pragma\:omp\:atomic$ wymusza niepodzielność podczas odczytu oraz zapisu zmiennej $sum$, będącą zmienną współdzielną przez wszystkie wątki, które jest wykonywane w sposób sekwencyjny. \\
Zapewnia również synchronizację na poziomie sprzętowym, czego konsekwencją jest unieważnienie linii pamięci na wszystkich innych procesorach oraz pamięci operacyjnej, które zawierają tą zmienną. Synchronizacja wątków jest realizowana za pomocą zakładanej blokady.\\
W celu zapewnienia atomowości uaktualnienia zmiennej współdzielonej w systemie, można skorzystać z dyrektywy $\#pragma\:omp\:critical$.
\subsection{PI4}
W celu unieknięcia wieloktornego zapisu i odczytu zmiennej $sum$ używając dyrektywy $\#pragma\:omp\:atomic$, wprowadzono zmienną prywatne $sum1$, przechowującą sumy dla poszczególnych wątków. \\
Dyrektywa $\#pragma\:omp\:atomic$ w dalszym ciągu jest używana przy końcowym zapisie do zmiennej- w tym przypadku odbywa się to poza pętlą, zatem każdy wątek robi to tylko raz na sam koniec.\\
Lokalność innych zmiennych nie uległa zmienie.
\subsection{PI5}
Wprowadzneie klauzuli $reduction(+:sum)$ dodanej do $\#pragma\:omp\:for$ zapewnia prywartność zmiennej $sum$, mimo jej deklaracji poza pętlą- za każdym razem tworzona nowa, prywatna zmienna.\\
Pisząc $reduction(\+:sum)$ informujemy kompilator, że do zmiennej $sum$ będziemy dodawać kolejno wyliczone wartości właśnie tej zmiennej. Kompilator utworzy odpowiednią liczbę prywatnych kopii zmiennej dla każdego wątku i rozdzieli iteracje pomiędzy dostępne wątki. Każdy wątek będzie operował tylko na swojej kopii zmiennej $sum$. Po wykonaniu wszystkich iteracji, wartości wyliczone przez wszystkie wątki są do siebie dodawane. Obliczona wartość zmiennej $sum$ typu reduction jest dostępna poza sekcją parallel.\\
Zastosowanie klauzuli jest równoważne z operacjami w PI4. Czasy przetważania są bardzo podobne, biorąc pod uwagę ich szybkość wykoanania.\\
Trzeba pamiętać, że obecne rozwiązanie ma swoje wady- przy większych, pod względem zajmowanej pamięci, strukturach może zdarzyć się, że obiekt nie zmieści się na pamieci poziomu pierwszego. Wątek traci czas na ubieganie się o miejsce na zapis zmiennej, co powoduje dłuższe przetwarzanie. 
\subsection{PI6}
W tym przykładzie zastosowano tablicę jako strukturę przechowująca zmienne prywatne, wywoływane unikalnymi numerami id danego wątku. \\
Trzeba pamiętać o tym, że lokalność zmiennych uwzględniona w kodzie programu, będąca rozwiązaniem koncepcyjnie lokalnym, nie jest tym samym co lokalność z poziomu linni pamięci.\\
Istnieje możliwość wystąpienia długiego przetwarzania programu. Jest to spowodowane tym, iż elementy tablicy są położone najprawdopodobniej w tej samej linii pamieci podręcznej. Możliwe jest wystąpenie false sharingu- podczas zapisu wartości do zmiennej przez dany wątek, może nastąpić unieważnienie linni pamieci, z której korzystaja inne wątki, czego natsępstwem moze być wydłużenie czasu przetwarzania.
\subsection{PI7}
Eksperyment miał na celu wyznaczenie długości linii pamięci podręcznej procesora. \\
W celu otrzymania tej informacji, wykonujemy przetwarzanie na dwóch sąsiednich elementach tablicy. Podczas przetwarzania można zaobserować moment, w którym czas przetwarznaia skraca się. Jest to spowodowane zniwelowaniem false sharingu- jeden z wątków pracuje na wczesniej wykorzystywanej linii pamięci, kiedy drugi przechodzi już na nową.\\
Powyższa sytuacja powtarza się cyklinie co 8 iteracji. Mając na uwadze wielkość zmiennej typu $double$ równą $8B$ można wyznaczyć długość linii pamięci podręcznej procesora:
\begin{center}
    $8 * 8 = 64B$
\end{center}
\end{document}
